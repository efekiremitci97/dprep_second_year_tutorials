---
title: "R For Social Scientists - Chapter 3 and 4"
author: "Efe Kiremitci"
date: "2022-09-11"
output: pdf_document
---
# Chapter 3 - Starting with Data

## What are data frames and tibbles

Data frames are the de facto data structure for tabular data in R, and what we use for data processing, statistics, and plotting. A data frame is the representation of data in the format of a table where the columns are vectors, each column must contain a single type of data (integers, characters, factors).

```{r eval=TRUE}
library(tidyverse)
library(here)

interviews <- read_csv(
  here("data", "SAFI_clean.csv"),
  na = "NULL")

```

In the above code, we notice the here() function takes folder and file names as inputs (e.g., "data", "SAFI_clean.csv"), each enclosed in quotations ("") and separated by a comma. The here() will accept as many names as are necessary to navigate to a particular file (e.g., here("analysis", "data", "surveys", "clean", "SAFI_clean.csv)).

The here() function can accept the folder and file names in an alternate format, using a slash (“/”) rather than commas to separate the names. The two methods are equivalent, so that here("data", "SAFI_clean.csv") and here("data/SAFI_clean.csv") produce the same result.

Overall, read.csv() behaves similar to read_csv(), with a few notable differences. First, read.csv() coerces column names with spaces and/or special characters to different names (e.g. interview date becomes interview.date). Second, read.csv() stores data as a data.frame, where read_csv() stores data as a tibble.

If we want to check that our data has been loaded, we can see the contents of the data frame by typing its name: interviews in the console.

```{r eval=TRUE}
interviews ## first ten rows

view(interviews) # opens the dataset in a different tab

head(interviews) # first 6-7 rows as a first glimpse to the data

```
Note that read_csv() actually loads the data as a tibble. A tibble is an extension of R data frames used by the tidyverse. When the data is read using read_csv(), it is stored in an object of class tbl_df, tbl, and data.frame. You can see the class of an object with
```{r eval=TRUE}
class(interviews)

```

## Inspecting data frames

When calling a tbl_df object (like interviews here), there is already a lot of information about our data frame being displayed such as the number of rows, the number of columns, the names of the columns, and as we just saw the class of data stored in each column. However, there are functions to extract this information from data frames. Here is a non-exhaustive list of some of these functions. 

Size
  - dim(interviews) - returns a vector with the number of rows as the first element, and the number of columns as the second element (the dimensions of the object)
  - nrow(interviews) - returns the number of rows
  - ncol(interviews) - returns the number of columns
  
Content
  - head(interviews) - shows the first 6 rows
  - tail(interviews) - shows the last 6 rows

Names
  - names(interviews) - returns the colum names (synonyms of colnames() for data.frame objects)
  
Summary
  - str(interviews) - structure of the object and information about the class, length and content of each column
  - summary(interviews) - summary statistics for each column
  - glimpse(interviews) - returns the number of columns and rows of the tibble, the names and class of each column, and previews as many values will fit on the screen. Unlike the other inspecting functions listed above, glimpse() is not a “base R” function so you need to have the dplyr or tibble packages loaded to be able to execute it.

Note: most of these functions are “generic.” They can be used on other types of objects besides data frames or tibbles.

## Indexing and subsetting data frames

Our interviews data frame has rows and columns (it has 2 dimensions). In practice, we may not need the entire data frame; for instance, we may only be interested in a subset of the observations (the rows) or a particular set of variables (the columns). If we want to extract some specific data from it, we need to specify the “coordinates” we want from it. Row numbers come first, followed by column numbers.

```{r eval=TRUE}
# first element in the first column of the tibble
interviews[1, 1]

```

```{r eval=TRUE}
# first element in the 6th column of the tibble

interviews[1, 6]
```
```{r eval=TRUE}
# first column of the tibble as a vector
interviews[[1]]

```

```{r}
## first column of the tibble
interviews[1]
```

```{r}
# first three element in the 7th column of the tibble
interviews[1:3, 7]
```

```{r eval=TRUE}
# the 3rd row of the tibble
interviews[3,]
```
```{r eval=TRUE}
# equivalent to head_interviews <- head(interviews)
head_interviews <- interviews[1:6, ] # just like head() it shows the first 6 rows of the dataset

interviews[-c(7:131), ]   # Equivalent to head(interviews)

```

```{r eval=TRUE}
# The whole tibble, except the first column
interviews[, -1]
```
tibbles can be subset by calling indices (above examples), but also by calling their column names directly
```{r eval=TRUE}
interviews["village"]       # Result is a tibble

interviews[, "village"]     # Result is a tibble

interviews[["village"]]     # Result is a vector

interviews$village          # Result is a vector

```
 ## Example
 
 1. Create a tibble (interviews_100) containing only the data in row 100 of the interviews dataset
 2. Notive how nrow() gave you the number of rows in the tibble?
  - Use that number to pull out just that last rows in the tibble.
  - Compare that with what you see as the last row using tail() to make sure it's meeting expectations
  - Pull out that last row using nrow() instead of the row number.
  - Create a new tibble (interviews_last) from that last row.
 3. Using the number of rows in the interviews dataset that you found in question 2, extract the row that is in the middle of the dataset. Store the content of this middle row in an object named interviews_middle. (hint: This dataset has an odd number of rows, so finding the middle is a bit trickier than dividing n_rows by 2. Use the median( ) function and what you’ve learned about sequences in R to extract the middle row!

 4. Combine nrow() with the - notation above to reproduce the behavior of head(interviews), keeping just the first through 6th rows of the interviews dataset.

```{r eval=TRUE}
interviews_100 <- interviews[100, ] # step 1

nrow(interviews) # to see how many rows dataset has
nrows <- nrow(interviews)

interviews_last <- interviews[nrows, ] 

interviews_middle <- interviews[median(1:nrows), ] # 3

interviews_head <- interviews[-(7:nrows), ] # 4
```

## Factors

R has a special data class, called factor, to deal with categorical data that you may encounter when creating plots or doing statistical analyses. Factors are very useful and actually contribute to making R particularly well suited to working with data. So we are going to spend a little time introducing them.

Factors represent categorical data. They are stored as integers associated with labels and they can be ordered (ordinal) or unordered (nominal). Factors create a structured relation between the different levels (values) of a categorical variable, such as days of the week or responses to a question in a survey. This can make it easier to see how one element relates to the other elements in a column. While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.

Once created, factors can only contain a pre-defined set of values, known as levels. By default, R always sorts levels in alphabetical order. For instancem if you have a factor with 2 levels:

```{r eval=TRUE}

respondent_floor_type <- factor(c("earth", "cement", "earth"))

```
R will assign 1 to the level "cement" and 2 to the level "earth" (because c comes before e even though the first element is in this vector is "earth"). You can see this by using the function levels() and you can find the number of levels using nlevels():

```{r eval=TRUE}
levels(respondent_floor_type) #name of the levels

```

```{r eval=TRUE}
nlevels(respondent_floor_type) #number of levels
```
Sometimes, the order of the factors does not matter. Other times you might want to specify the order because it is meaningful (e.g., “low”, “medium”, “high”). It may improve your visualization, or it may be required by a particular type of analysis. Here, one way to reorder our levels in the respondent_floor_type vector would be:

```{r eval=TRUE}
respondent_floor_type # current order
```

```{r eval=TRUE}
respondent_floor_type <- factor(respondent_floor_type,
                                levels = c("earth", "cement")) # we changed the order and make earth the first level

respondent_floor_type
```
In R’s memory, these factors are represented by integers (1, 2), but are more informative than integers because factors are self describing: "cement", "earth" is more descriptive than 1, and 2. Which one is “earth”? You wouldn’t be able to tell just from the integer data. Factors, on the other hand, have this information built in. It is particularly helpful when there are many levels. It also makes renaming levels easier. Let’s say we made a mistake and need to recode “cement” to “brick”. We can do this using the fct_recode() function from the forcats package (included in the tidyverse) which provides some extra tools to work with factors.

```{r eval=TRUE}
levels(respondent_floor_type) # check current order

respondent_floor_type <- fct_recode(respondent_floor_type, brick = "cement")

levels(respondent_floor_type) # check the levels after you changed it
``` 
So far, your factor is unordered, like a nominal variable. R does not know the difference between a nominal and an ordinal variable. You make your factor an ordered factor by using the ordered=TRUE option inside your factor function. Note how the reported levels changed from the unordered factor above to the ordered version below. Ordered levels use the less than sign < to denote level ranking.

```{r eval=TRUE}
respondent_floor_type_ordered <- factor(respondent_floor_type, ordered = TRUE)

respondent_floor_type_ordered
```

## Converting factors

If you need to convert a factor to a character vector, you use as.character(x)

```{r eval=TRUE}
as.character(respondent_floor_type)

```
Converting factors where the levels appear as numbers (such as concentration levels, or years) to a numeric vector is a little trickier. The as.numeric() function returns the index values of the factor, not its levels, so it will result in an entirely new (and unwanted in this case) set of numbers. One method to avoid this is to convert factors to characters, and then to numbers. Another method is to use the levels() function. Compare:

```{r eval=TRUE}
year_fct <- factor(c(1990, 1983, 1977, 1998, 1990))

as.numeric(year_fct) # The outcome is the order of the levels, not the levels itself
```

```{r eval=TRUE}
as.numeric(as.character(year_fct)) # first, we convert them into characters and then numeric values

```

```{r eval=TRUE}
# The recommended way

as.numeric(levels(year_fct))[year_fct]
```
Notice that in the recommended levels() approach, three important steps occur:
  - We obtain all the factor levels using levels(year_fct)
  - We convert these levels to numeric values using as.numeric(levels(year_fct))
  - We then access these numeric values using the underlying integers of the vector year_fct inside the square brackets
  
## Renaming Factors

When your data is stored as a factor, you can use the plot() function to get a quick glance at the number of observations represented by each factor level. Let’s extract the memb_assoc column from our data frame, convert it into a factor, and use it to look at the number of interview respondents who were or were not members of an irrigation association:

```{r eval=TRUE}
## create a vector from the data frame column "memb_assoc"
memb_assoc <- interviews$memb_assoc

## convert it into a factor

memb_assoc <- as.factor(memb_assoc)

## let's see what it looks like
memb_assoc
```

```{r eval=TRUE}
## bar plot of the number of interview respondents who were
## members of irrigation association:
plot(memb_assoc)
```
Looking at the plot compared to the output of the vector, we can see that in addition to “no”s and “yes”s, there are some respondents for which the information about whether they were part of an irrigation association hasn’t been recorded, and encoded as missing data. They do not appear on the plot. Let’s encode them differently so they can counted and visualized in our plot.

```{r eval=TRUE}

## let's recreate the vector from the data frame column "memb_assoc"
memb_assoc <- interviews$memb_assoc

## replace the missing data with "undetermined"
memb_assoc[is.na(memb_assoc)] <- "undetermined"

## convert it into a factor

memb_assoc <- as.factor(memb_assoc)
memb_assoc
```

```{r eval=TRUE}
## bar plot of the number of interview respondents who were
## members of irrigation association:
plot(memb_assoc)
```
## Example
  - Rename the levels of the factor to have the first letter in uppercase: “No”,”Undetermined”, and “Yes”.
  - Now that we have renamed the factor level to “Undetermined”, can you recreate the barplot such that “Undetermined” is last (after “Yes”)?


```{r eval=TRUE}
memb_assoc <- fct_recode(memb_assoc, No = "no",
                         Undetermined = "undetermined", Yes = "yes") # Rename the levels

memb_assoc

memb_assoc <- factor(memb_assoc, levels= c("No", "Yes", "Undetermined")) # ordering the levels

plot(memb_assoc)
```
## Formatting Dates

One of the most common issues that new (and experienced!) R users have is converting date and time information into a variable that is appropriate and usable during analyses. A best practice for dealing with date data is to ensure that each component of your date is available as a separate variable. In our dataset, we have a column interview_date which contains information about the year, month, and day that the interview was conducted. Let’s convert those dates into three separate columns.

```{r eval=TRUE}
str(interviews)
```
We are going to use the package lubridate, which is included in the tidyverse intallation but not loaded by default, so we have to load it explicitly with library(lubridate). 
```{r eval=TRUE}
install.packages("lubridate")
library(lubridate)
```
The lubridate function ymd() takes a vector representing year, month, and day, and converts it to a Date vector. Date is a class of data recognized by R as being a date and can be manipulated as such. The argument that the function requires is flexible, but, as a best practice, is a character vector formatted as “YYYY-MM-DD”

```{r eval=TRUE}
dates <- interviews$interview_date

str(dates)
```
When we imported the data in R, read_csv() recognized that this column contained date information. We can now use the day(), month() and year() functions to extract this information from the date, and create new columns in our data frame to store it:
```{r eval=TRUE}
interviews$day <- day(dates)

interviews$month <- month(dates)

interviews$year <- year(dates)

interviews
```
In our example, aboce the interview_date() column was read in correctly as a Date variable but generally that is not the case. Date columns are often read in as character variables and one can use the as_Date() function to convert them to the appropriate Date/POSIXct format.

Let's say we have a vector of dates in character format:
```{r eval=TRUE}

char_dates <- c("7/31/2012", "8/9/2014", "4/30/2016")

str(char_dates)
```

We can convert this vector to dates as:
```{r eval=TRUE}

as_date(char_dates, format = "%m/%d/%Y")
```
We can also use functions ymd(), mdy(), dmy() to convert character variables to date.
```{r eval=TRUE}
mdy(char_dates)
```


# Data Wrangling with dplyr and tidyr

dplyr is a package for making tabular data wrangling easier by using a limited set of functions that can be combined to extract and summarize insights from your data. It pairs nicely with tidyr which enables you to swiftly convert between different data formats (long vs. wide) for plotting and analysis.

## Learning dplyr and tidyr
```{r eval=TRUE}
library(tidyverse)
library(here)

interviews <- read_csv(here("data", "SAFI_clean.csv"), na = "NULL")

## inspect the data
interviews

## preview the data
view(interviews)
```

We’re going to learn some of the most common dplyr functions:

  - select(): subset columns
  - filter(): subset rows on conditions
  - mutate(): create new columns by using information from other columns
  - group_by() and summarize(): create summary statistics on grouped data
  - arrange(): sort results
  - count(): count discrete values

## Selecting columns and filterin rows

To select columns of a dataframe, use select(). the first argument to this function is the dataframe (interviews), and the subsequent arguments are the columns o keep, separated by commas. Alternatively, if you are selecting columns adjacent to each other, you can use a : to select a range of columns, read as “select columns from __ to __.” You may have done something similar in the past using subsetting. select() is essentially doing the same thing as subsetting, using a package (dplyr) instead of R’s base functions.

```{r eval=TRUE}
# to select columns throught the dataframe
select(interviews, village, no_membrs, months_lack_food)

# to do same thing with subsetting
interviews[c("village", "no_membrs", "months_lack_food")]

# to select a series of connected columns
select(interviews, village:respondent_wall_type)
```
To choose rows based on specific criteria, we can use the filter() function. The argument after the dataframe is the condition we want our final dataframe to adhere to (village name is Chirodzo):

```{r eval=TRUE}
filter(interviews, village == "Chirodzo")
```
We can also specify multiple conditions within the filter() function. We can combine conditions using either “and” or “or” statements. In an “and” statement, an observation (row) must meet every criteria to be included in the resulting dataframe. To form “and” statements within dplyr, we can pass our desired conditions as arguments in the filter() function, separated by commas:

```{r eval=TRUE}
## filter observations with "and" operator (comma)
# output dataframe satisfies ALL specified conditions
filter(interviews, village == "Chirodzo",
       rooms > 1,
       no_meals >2)
```
We can also form “and” statements with the & operator instead of commas:
```{r eval=TRUE}
# filters observations with "&" logical operator
# output dataframe satisfies ALL specified conditions
filter(interviews, village == "Chirodzo" & 
                   rooms > 1 & 
                   no_meals > 2)
```
In an "or" statement, observations must meet at least one of the specified conditions. To form "or" statement we use the logical operator for "or", which is the verical bar (|)
```{r eval=TRUE}

#filter observations with "|" logical operator
# output dataframe satisfies AT LEAST ONE of the specified conditions
filter(interviews, village=="Chirodzo" | village =="Ruaca")
```
## Pipes

What if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes.
With intermediate steps, you create a temporary dataframe and use that as input to the next function, like this:
```{r eval=TRUE}

interviews2<- filter(interviews, village=="Chirodzo")
interviews_ch<- select(interviews2, village:respondent_wall_type)
```
This is readable, but can clutter up your workspace with lots of objects that you have to name individually. With multiple steps, that can be hard to keep track of.
You can also nest functions (i.e. one function inside of another), like this:
```{r eval=TRUE}

interviews_ch <- select(filter(interviews, village =="Chirodzo"),
                        village:respondent_wall_type)
```
This is handy, but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, filtering, then selecting).

The last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. Pipes in R look like %>% and are made available via the magrittr package, installed automatically with dplyr. If you use RStudio, you can type the pipe with:

```{r eval=TRUE}
interviews %>% 
  filter(village =="Chirodzo") %>% 
  select(village:respondent_wall_type)
```
In the above code, we use the pipe to send the interviews dataset first through filter() to keep rows where village is “Chirodzo”, then through select() to keep only the columns from village to respondent_wall_type. Since %>% takes the object on its left and passes it as the first argument to the function on its right, we don’t need to explicitly include the dataframe as an argument to the filter() and select() functions any more.

If we want to create a new object with this smaller version of data, we can assign it a new name:
```{r eval=TRUE}
interviews_ch <- interviews %>% 
  filter(village == "Chirodzo") %>% 
  select(village:respondent_wall_type)

interviews_ch
```
## Example
  - Using pipes, subset the interviews data to include interviews where respondents were members of an irrigation association (memb_assoc) and retain only the columns affect_conflicts, liv_count, and no_meals.
```{r eval=TRUE}
interviews %>% 
  filter(memb_assoc == "yes") %>% 
  select(affect_conflicts, liv_count, no_meals)
```
## Mutate 

Frequently you'll want to create new columns based on the valus in existing columns, for example to do unit conversions, or to find the ratio of the values in two columns. For this we'll use mutate()

We might interested in the ratio of number of household members to rooms used for sleeping (avg. number of people per room)

```{r eval=TRUE}
interviews %>% 
  mutate(people_per_room = no_membrs / rooms)
```
We may be interested in investigating whether being a member of an irrigation association had any effect on the ratio of household members to rooms. To look at this relationship, we will first remove data from our dataset where the respondent didn’t answer the question of whether they were a member of an irrigation association. These cases are recorded as “NULL” in the dataset.

To remove these cases, we could insert a filter() in the chain:

```{r eval=TRUE}
interviews %>% 
  filter(!is.na(memb_assoc)) %>% 
  mutate(people_per__room = no_membrs / rooms)
```
The ! symbol negates the result of the is.na(). Thus, if is.na() returns a value of TRUE (because the memb_assoc is missing), the ! symbol negates this and says we only want values of FALSE, where memb_assoc is not missing.

## Example

Create a new dataframe from the interviews data that meets the following criteria: contains only the village column and a new column called total_meals containing a value that is equal to the total number of meals served in the household per day on average (no_membrs times no_meals). Only the rows where total_meals is greater than 20 should be shown in the final dataframe.

Hint: think about how the commands should be ordered to produce this data frame!

```{r eval=TRUE}
# Example Solution
interviews_total_meals <- interviews %>% 
  mutate(total_meals = no_meals * no_membrs) %>% 
  filter(total_meals > 20) %>%
  select(village, total_meals)
```
## Split-apply-combine data analysis and the summarize() function

Many data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results.

### The summarize() function

group_by() is often used together with summarize(), which collapses each group into a single-row summary of that group. group_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics. So to compute the average household size by village:
```{r eval=TRUE}

interviews %>% 
  group_by(village) %>% 
  summarize(mean_no_membrs = mean(no_membrs))
```
You may also have noticed that the output from these calls doesn’t run off the screen anymore. It’s one of the advantages of tbl_df over dataframe.

You can also group by multiple columns:

```{r eval=TRUE}
interviews %>% 
  group_by(village, memb_assoc) %>% 
  summarize(mean_no_membrs = mean(no_membrs))
```
Note that the output is a grouped tibble (by village). To obtain an ungrouped tibble, use the ungroup function:
```{r eval=TRUE}
interviews %>% 
  group_by(village, memb_assoc) %>% 
  summarize(mean_no_membrs = mean(no_membrs)) %>% 
  ungroup()
```
When grouping both by village and memb_assoc, we see rows in our table for respondents who did not specify whether they were a member of an irrigation association. We can exclude those data from our table using a filter step.
```{r eval=TRUE}
interviews %>% 
  filter(!is.na(memb_assoc)) %>%  #excluding NA or NULL in that column
  group_by(village, memb_assoc) %>% 
  summarize(mean_no_membrs = mean(no_membrs))
```
Once the data are grouped, you can also summarize multiple variables at the same time (and not necessarily on the same variable). For instance, we could add a column indicating the minimum household size for each village for each group (members of an irrigation association vs not):

```{r eval=TRUE}
interviews %>% 
  filter(!is.na(memb_assoc)) %>% 
  group_by(village, memb_assoc) %>% 
  summarize(mean_no_membrs = mean(no_membrs),
            min_membrs = min(no_membrs))
```
It is sometimes useful to rearrange the rsult of a query to inspect the values. For instance, we can sort on min_membrs to put the group with the smallest household first:
```{r eval=TRUE}
interviews %>% 
  filter(!is.na(memb_assoc)) %>% 
  group_by(village, memb_assoc) %>% 
  summarize(mean_no_membrs = mean(no_membrs),
            min_membrs = min(no_membrs)) %>% 
  arrange(min_membrs) # sorting from smallest to largest
```
To sort in descending order, we need to add the desc() function. If we want to sort the results by decreasing order of minimum household size:

```{r eval=TRUE}

interviews %>% 
  filter(!is.na(memb_assoc)) %>% 
  group_by(village, memb_assoc) %>% 
  summarize(mean_no_membrs = mean(no_membrs),
            min_membrs = min(no_membrs)) %>% 
  arrange(desc(min_membrs)) # descending order
```

### Counting 

When working with data, we often want to know the number of observations found for each factor or combination of factors. For this task, dplyr provides count(). For example, if we wanted to count the number of rows of data for each village, we would do:
```{r eval=TRUE}
interviews %>% 
  count(village)
```
For convenience, count() provides the sort argument to get results in decreasing order:
```{r eval=TRUE}
interviews %>% 
  count(village, sort = TRUE)
```
## Example
  - 1. How many households in the survey have average of two meals per day? Three meals per day? Are there any other numbers of meals represented?
  - 2. USe group_by() and summarize() to find the mean, min, and max number of household members for each village. Also, add the number of observations.
  - 3. What was the largest household interviewed in each month?
```{r eval=TRUE}
# Q1

interviews %>% 
  count(no_meals, sort = TRUE)
```

```{r eval=TRUE}
# Q2
interviews %>% 
  group_by(village) %>%
  summarize(mean_no_membrs = mean(no_membrs),
            min_no_membrs = min(no_membrs),
            max_no_membrs = max(no_membrs),
            n = n() # eger boyle tanimlamassan tabloda da n() olarak gozukuyor. o yuzden n = n() seklinde tanimliyoruz 
            )
  
  
```


```{r}
# Q3

interviews %>% 
  mutate(month = month(interview_date),
         day = day(interview_date),
         year = year(interview_date)) %>% 
           group_by(year, month) %>% 
  summarize(max_no_membrs = max(no_membrs))
  

```
## Reshaping with pivot_wider() and pivot_longer()

There are essentially three rules that define a “tidy” dataset:

  - Each variable has its own column
  - Each observation has its own row
  - Each value must have its own cell
In this section we will explore how these rules are linked to the different data formats researchers are often interested in: “wide” and “long”. This tutorial will help you efficiently transform your data shape regardless of original format. First we will explore qualities of the interviews data and how they relate to these different types of data formats.


```{r eval=TRUE}

interviews %>% 
  select(key_ID, village, interview_date, instanceID)
```
As seen in the code below, for each interview date in each village no instanceIDs are the same. Thus, this format is what is called a “long” data format, where each observation occupies only one row in the dataframe.

```{r eval=TRUE}
interviews %>% 
  filter(village=="Chirodzo") %>% 
  select(key_ID, village, interview_date, instanceID) %>% 
  sample_n(size = 10)
```
We notice that the layout or format of the interviews data is in a format that adheres to rules 1-3, where

  - each column is a variable
  - each row is an observation
  - each value has its own cell
This is called a “long” data format. But, we notice that each column represents a different variable. In the “longest” data format there would only be three columns, one for the id variable, one for the observed variable, and one for the observed value (of that variable). This data format is quite unsightly and difficult to work with, so you will rarely see it in use.

Alternatively, in a “wide” data format we see modifications to rule 1, where each column no longer represents a single variable. Instead, columns can represent different levels/values of a variable. For instance, in some data you encounter the researchers may have chosen for every survey date to be a different column.

These may sound like dramatically different data layouts, but there are some tools that make transitions between these layouts much simpler than you might think! The gif below shows how these two formats relate to each other, and gives you an idea of how we can use R to shift from one format to the other.

## Questions which warrant different data formats

In interviews, each row contains the values of variables associated with each record (the unit), values such as the village of the respondent, the number of household members, or the type of wall their house had. This format allows for us to make comparisons across individual surveys, but what if we wanted to look at differences in households grouped by different types of housing construction materials?

To facilitate this comparison we would need to create a new table where each row (the unit) was comprised of values of variables associated with housing material (e.g. the respondent_wall_type).
In practical terms this means the values of the wall construction materials in respondent_wall_type (e.g. muddaub, burntbricks, cement, sunbricks) would become the names of column variables and the cells would contain values of TRUE or FALSE, for whether that house had a wall made of that material.

Once we we’ve created this new table, we can explore the relationship within and between villages. The key point here is that we are still following a tidy data structure, but we have reshaped the data according to the observations of interest.

Alternatively, if the interview dates were spread across multiple columns, and we were interested in visualizing, within each village, how irrigation conflicts have changed over time. This would require for the interview date to be included in a single column rather than spread across multiple columns. Thus, we would need to transform the column names into values of a variable.

We can do both these of transformations with two tidyr functions, pivot_wider() and pivot_longer().

## Pivoting Wider

pivot_wider() takes the three principal arguments:
  1. the data
  2. the names_from column variable whose values will become new column names.
  3. the values_from column variable whose values will fill the column variables.
  
Further arguments include values_fill which, if set, fills in the missing values with the value provided.
  
Let’s use pivot_wider() to transform interviews to create new columns for each type of wall construction material. We will make use of the pipe operator as have done before. Because both the names_from and values_from parameters must come from column values, we will create a dummy column (we’ll name it wall_type_logical) to hold the value TRUE, which we will then place into the appropriate column that corresponds to the wall construction material for that respondent. When using mutate() if you give a single value, it will be used for all observations in the dataset.

For each row in our newly pivoted table, only one of the newly created wall type columns will have a value of TRUE, since each house can only be made of one wall type. The default value that pivot_wider uses to fill the other wall types is NA.

If instead of the default value being NA, we wanted these values to be FALSE, we can insert a default value into the values_fill argument. By including values_fill = list(wall_type_logical = FALSE) inside pivot_wider(), we can fill the remainder of the wall type columns for that row with the value FALSE.


```{r eval=TRUE}

interviews_wide <- interviews %>% 
  mutate(wall_type_logical = TRUE) %>% 
  pivot_wider(names_from = respondent_wall_type,
              values_from = wall_type_logical,
              values_fill = list(wall_type_logical = FALSE))
dim(interviews)
dim(interviews_wide)
```
View the interviews_wide dataframe and notice that there is no longer a column titled respondent_wall_type. This is because there is a default parameter in pivot_wider() that drops the original column. The values that were in that column have now become columns named muddaub, burntbricks, sunbricks, and cement. You can use dim(interviews) and dim(interviews_wide) to see how the number of columns has changed between the two datasets.

## Pivoting Longer

The opposing situation could occur if we had been provided with data in the form of interviews_wide, where the building materials are column names, but we wish to treat them as values of a respondent_wall_type variable instead.

In this situation we are gathering these columns turning them into a pair of new variables. One variable includes the column names as values, and the other variable contains the values in each cell previously associated with the column names. We will do this in two steps to make this process a bit clearer.

pivot_longer() takes four principal arguments:

  1. the data
  2. cols are the names of the columns we use to fill the a new values variable (or to drop)
  3. the names_to column variable we wisht to create the cols provided.
  4. the values_to variable we wish to create and fill values associated with the cols provided.
  
To recreate our original dataframe, we will use the following:

  1. the data - interviews_wide
  2. a list of cols (columns) that are to be reshaped; these can be specified using a : if the columns to be reshaped are in one area of the dataframe, or with a vector (c()) command if the columns are spread throughout the dataframe.
  3. the names_to column will be a character string of the name the column these columns will be collapsed into ("respondent_wall_type")
  4. the values_to column will be a character string of the name of the column the values of the collapsed columns will be inserted into ("wall_type_logical"). This column will be populated with values of TRUE or FALSE.
```{r eval=TRUE}
interviews_long <- interviews_wide %>% 
  pivot_longer(cols = c("muddaub", "cement", "sunbricks", "burntbricks"),
               names_to = "respondent_wall_type",
               values_to = "wall_type_logical")
```
This creates a dataframe with 524 rows (4 rows per interview respondent). The four rows for each respondent differ only in the value of the "respondent_wall_type" and "wall_type_logical" columns.

Only one row for each interview respondent is informative–we know that if the house walls are made of “sunbrick” they aren’t made of any other the other materials. Therefore, it would make sense to filter our dataset to only keep values where wall_type_logical is TRUE. Because wall_type_logical is already either TRUE or FALSE, when passing the column name to filter(), it will automatically already only keep rows where this column has the value TRUE. We can then remove the wall_type_logical column.


```{r eval=TRUE}
interviews_long <- interviews_wide %>% 
  pivot_longer(cols = c(burntbricks, cement, muddaub, sunbricks),
               names_to = "respondent_wall_type",
               values_to = "wall_type_logical") %>% 
  filter(wall_type_logical) %>% 
  select(-wall_type_logical)
```

## Applying pivot_wider() to clean our data

Now that we’ve learned about pivot_longer() and pivot_wider() we’re going to put these functions to use to fix a problem with the way that our data is structured. In the spreadsheets lesson, we learned that it’s best practice to have only a single piece of information in each cell of your spreadsheet. In this dataset, we have several columns which contain multiple pieces of information. For example, the items_owned column contains information about whether our respondents owned a fridge, a television, etc. To make this data easier to analyze, we will split this column and create a new column for each item. Each cell in that column will either be TRUE or FALSE and will indicate whether that interview respondent owned that item (similar to what we did previously with wall_type).

```{r eval=TRUE}
interviews_items_owned <- interviews %>% 
  separate_rows(items_owned, sep = ";") %>% 
  replace_na(list(items_owned = "no_listed_items")) %>% 
  mutate(items_owned_logical = TRUE) %>% # burada sadece true olanlari alacagimiz icin, yeni bir variable yaratip FALSE olanlari attik
  pivot_wider(names_from = items_owned,
              values_from = items_owned_logical,
              values_fill = list(items_owned_logical = FALSE))

nrow(interviews_items_owned)

```
There are couple of new concepts in this code chunk, so let's walk through it line by line. First we create a new object (interviews_items_owned) based on the interviews dataframe.
```{r eval=TRUE}

# interviews_items_owned <- interviews %>% 
```

Then we use the new function separate_rows() from the tidyr package to separate the values of items_owned based on the presence of semi-colons(;). The values of this variable were multiple items separated by semi-colons, so this action creates a row for each item listed in a household's possession. Thus, we end up with a long format version of the dataset, with multiple rows for each respondent. For example, if a respondent has a television and a solar panel, that respondent will now have two rows, one with “television” and the other with “solar panel” in the items_owned column.
```{r eval=TRUE}
# separate_rows(items_owned, sep = ";") %>% 
```

One of the column is called `NA`. This is because some of the respondents did not own any of the items that was in the interviewer's list. We can use the replace_na() function to change these NA values to something more meaningful. The replace_na() function expects for you to give it a list() of columns that you would like to replace the NA values in, and the value that you would like to replace the NAs. This ends up looking like this:
```{r eval=TRUE}
# replace_na(list(items_owned = "no_listed_items")) %>% 
```

Next, we create a new variable named items_owned_logical, which has one value (TRUE) for every row. This makes sense, since each item in every row was owned by that household. We are constructing this variable so that when spread the items_owned across multiple columns, we can fill the values of those columns with logical values describing whether the household did (TRUE) or didn’t (FALSE) own that particular item.
```{r eval=TRUE}

# mutate(items_owned_logical = TRUE) %>% 
```

Lastly, we use pivot_wider() to switch from long format to wide format. This creates a new column for each of the unique values in the items_owned column, and fills those columns with the values of items_owned_logical. We also declare that for items that are missing, we want to fill those cells with the value of FALSE instead of NA
```{r eval=TRUE}

#pivot_wider(names_from = items_owned,
# values_from = items_owned_logical,
# values_fill = list(items_owned_logical = FALSE))
```

This format of the data allows us to do interesting things, like make a table showing the number of respondents in each village who owned a particular item:
```{r eval=TRUE}

interviews_items_owned %>% 
  filter(bicycle) %>% 
  group_by(village) %>% 
  count(bicycle)
```

Or below we calculate the average number of items from the list owned by respondents in each village. This code uses the rowSums() function to count the number of TRUE values in the bicycle to car columns for each row, hence its name. Note that we replaced NA values with the value no_listed_items, so we must exclude this value in the aggregation. We then group the data by villages and calculate the mean number of items, so each average is grouped by village.
```{r eval=TRUE}

interviews_items_owned %>% 
  mutate(number_items = rowSums(select(., bicycle:car))) %>% 
  group_by(village) %>% 
  summarize(mean_items = mean(number_items))
```

## Example
  - Create a new dataframe (named interviews_months_lack_food) that has one column for each month and records TRUE or FALSE for whether each interview respondent was lacking food in that month.
  - How many months (on average) were respondents without food if they did belong to an irrigation association? What about if they didn’t?


```{r eval=TRUE}
# Q1 Solution

interviews_months_lack_food <- interviews %>%
  separate_rows(months_lack_food, sep = ";") %>% 
  mutate(months_lack_food_logical = TRUE) %>% 
  pivot_wider(names_from = months_lack_food,
              values_from = months_lack_food_logical,
              values_fill = list(months_lack_food_logical = FALSE))
  
  
view(interviews_months_lack_food)
```

```{r eval=TRUE}
# Q2 Solution
interviews_months_lack_food %>% 
  mutate(number_months = rowSums(select(., Jan:May))) %>% 
  group_by(memb_assoc) %>% 
  summarize(mean_months = mean(number_months))
```
## Exporting Data

Similar to the read_csv(), w are going to create a new folder, data_output, in our working directory taht will store his generated dataset. We don't want to write generated datasets in the same directory as our raw data. It's good practice to keep them separate. The data folder should only contain the raw, unaltered data, and should be left alone to make sure we don’t delete or modify it. In contrast, our script will generate the contents of the data_output directory, so even if the files it contains are deleted, we can always re-generate them.

In preparation for our next lesson on plotting, we are going to create a version of the dataset where each of the columns includes only one data value. To do this, we will use pivot_wider to expand the months_lack_food and items_owned columns. We will also create a couple of summary columns.

```{r eval=TRUE}
interviews_plotting <- interviews %>% 
  ## pivot_wider by items_owned
  separate_rows(items_owned, sep = ";") %>% 
  ## if there were not items listed, changing NA to no_listed_items
  replace_na(list(items_owned = "no_listed_items")) %>% 
  mutate(items_owned_logical = TRUE) %>% 
  pivot_wider(names_from = items_owned,
              values_from = items_owned_logical,
              values_fill = list(items_owned_logical = FALSE)) %>% 
  ## pivot_wider by months_lack_food
  separate_rows(months_lack_food, sep = ";") %>% 
  mutate(months_lack_food_logical = TRUE) %>% 
  pivot_wider(names_from = months_lack_food,
              values_from = months_lack_food_logical,
              values_fill = list(months_lack_food_logical = FALSE)) %>% 
  ## add some summary columns
  mutate(number_months_lack_food = rowSums(select(., Jan:May))) %>% 
  mutate(number_items = rowSums(select(., bicycle:car)))
```

Now we can save this dataframe to our data_output directory
```{r eval=TRUE}
write_csv(interviews_plotting, file = "data_output/interviews_plotting.csv")
```

```{r}

```

```{r}

```














